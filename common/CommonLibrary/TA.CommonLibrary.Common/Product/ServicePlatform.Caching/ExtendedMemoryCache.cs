//-----------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
//-----------------------------------------------------------------------

using TA.CommonLibrary.ServicePlatform.Caching.Abstractions;
using System;
using System.Threading.Tasks;
using System.Threading;
using TA.CommonLibrary.CommonDataService.Common.Internal;
using TA.CommonLibrary.ServicePlatform.Caching.Activities;
using TA.CommonLibrary.ServicePlatform.Context;
using Microsoft.Extensions.Caching.Memory;

namespace TA.CommonLibrary.ServicePlatform.Caching
{
    /// <summary>
    /// An implementation of a cache where entries share a common type.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <seealso cref="TA.CommonLibrary.ServicePlatform.Caching.Abstractions.ICache{T}" />
    public class ExtendedMemoryCache<T> : IDisposable, ICache<T>
    {
        private readonly TimeSpan defaultAbsoluteExpirationTimeSpan;
        private MemoryCache memoryCache;
        private bool isDisposed = false;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExtendedMemoryCache{T}"/> class.
        /// </summary>
        /// <param name="defaultAbsoluteExpirationTimeSpan">The default absolute expiration time span.</param>
        /// <param name="memoryCache">The memory cache.</param>
        public ExtendedMemoryCache(TimeSpan defaultAbsoluteExpirationTimeSpan, MemoryCache memoryCache)
        {
            this.defaultAbsoluteExpirationTimeSpan = defaultAbsoluteExpirationTimeSpan;
            this.memoryCache = memoryCache;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExtendedMemoryCache{T}"/> class.
        /// </summary>
        /// <param name="defaultAbsoluteExpirationTimeSpan">The default absolute expiration time span.</param>
        public ExtendedMemoryCache(TimeSpan defaultAbsoluteExpirationTimeSpan) : this(defaultAbsoluteExpirationTimeSpan, new MemoryCache(new MemoryCacheOptions()))
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExtendedMemoryCache{T}"/> class.
        /// </summary>
        /// <param name="defaultAbsoluteExpirationTimeSpan">The default absolute expiration time span.</param>
        /// <param name="memoryCacheName">Name of the memory cache.</param>
        public ExtendedMemoryCache(TimeSpan defaultAbsoluteExpirationTimeSpan, string memoryCacheName) : this(defaultAbsoluteExpirationTimeSpan, new MemoryCache(new MemoryCacheOptions()))
        { }

        /// <summary>
        /// Gets the item from the cache or adds the value returned from the populating function.
        /// </summary>
        /// <param name="key">The key of the cache entry.</param>
        /// <param name="populatingFunction">The function which provides a Task which produces a fresh value. 
        /// If multiple calls to this method are made while a Task generated by a populatingFunction is in flight, they will attach to the
        /// Task from the first call. 
        /// If the Task is faulted, it will be removed from the cache, and subsequent calls will again attempt to execute the populatingFunction
        /// to retrieve a fresh value.</param>
        /// <returns>
        /// The object on the cache.
        /// </returns>
        public Task<T> GetOrAddValueAsync(string key, Func<Task<T>> populatingFunction)
        {
            CheckNotDisposed();
            Contract.CheckNonEmpty(key, nameof(key));
            Contract.CheckValue(populatingFunction, nameof(populatingFunction));

            return ServiceContext.Activity.Execute<ExtendedMemoryCacheGetOrAddActivityType, Task<T>>(
                ExtendedMemoryCacheGetOrAddActivityType.Instance,
                () =>
                {

                    // Create a lightweight cache item and add it or get the current cache item.
                    var newCacheItem = new LockableCachedItem();
                    var cacheItemObject = memoryCache.GetOrCreate(key, entry => newCacheItem);
                    ////AddOrGetExisting(key, newCacheItem, GetCachePolicy());
                    var cacheItem = cacheItemObject as LockableCachedItem ?? newCacheItem;

                    if (cacheItem.item != null)
                    {
                        return cacheItem.item;
                    }

                    return AcquireLockAndGetOrUpdate(populatingFunction, cacheItem);
                });
        }

        /// <summary>
        /// Gets the item from the cache or adds the value returned from the populating function.
        /// </summary>
        /// <param name="key">The key of the cache entry.</param>
        /// <param name="populatingFunction">The function which provides the new value in the event of a cache miss.</param>
        /// <returns>
        /// The object on the cache.
        /// </returns>
        public Task<T> GetOrAddValueAsync(string key, Func<T> populatingFunction)
        {
            return GetOrAddValueAsync(key, () => Task.FromResult(populatingFunction.Invoke()));
        }

        /// <summary>
        /// Gets an item of the cache if the cache has the value.
        /// </summary>
        /// <param name="key">The key of the cache entry.</param>
        /// <returns>
        /// The object on the cache.
        /// </returns>
        public Task<T> GetValueAsync(string key)
        {
            CheckNotDisposed();
            Contract.CheckNonEmpty(key, nameof(key));

            return ServiceContext.Activity.Execute<ExtendedMemoryCacheGetActivityType, Task<T>>(
                ExtendedMemoryCacheGetActivityType.Instance,
                () =>
                {
                    LockableCachedItem cached = memoryCache.Get(key) as LockableCachedItem;
                    return cached?.item;
                });
        }

        /// <summary>
        /// Removes the specified value from the cache.
        /// </summary>
        /// <param name="key">The key of the cache entry.</param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public Task RemoveAsync(string key)
        {
            CheckNotDisposed();
            Contract.CheckNonEmpty(key, nameof(key));

            return ServiceContext.Activity.Execute<ExtendedMemoryCacheRemoveActivityType, Task>(
                ExtendedMemoryCacheRemoveActivityType.Instance,
                () =>
                {
                    memoryCache.Remove(key);
                    return Task.FromResult(0);
                });
        }

        /// <summary>
        /// Adds a value to the cache.
        /// </summary>
        /// <param name="key">The key of the cache entry.</param>
        /// <param name="value">The value to cache.</param>
        /// <param name="cacheObjectLifetime">The initial lifetime of the object in cache.</param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public Task SetAsync(string key, T value, TimeSpan? cacheObjectLifetime = null)
        {
            return ServiceContext.Activity.Execute<ExtendedMemoryCacheSetActivityType, Task>(
                ExtendedMemoryCacheSetActivityType.Instance,
                () =>
                {
                    var itemWrapper = new LockableCachedItem { item = Task.FromResult(value) };
                    memoryCache.Set(key, itemWrapper, cacheObjectLifetime ?? defaultAbsoluteExpirationTimeSpan);
                    return Task.FromResult(0);
                });
        }

        private static async Task<T> AcquireLockAndGetOrUpdate(Func<Task<T>> updater, LockableCachedItem cacheItem)
        {
            await cacheItem.semaphore.WaitAsync().ConfigureAwait(false);

            try
            {
                // We have the lock, let's see if someone else has already updated the value.
                if (cacheItem.item != null)
                {
                    return await cacheItem.item;
                }

                var task = updater();
                cacheItem.item = task;

                // This assignment is used to simultaneously resolve the warning that we aren't awaiting the task and to signal 
                // the same to the reader of the code. The consumer of the cache awaits the cached tasks.
                var intentionallyUnawaited = task.ContinueWith(t =>
                {
                    // We only want to assign the cacheItem.item in the case where the updater is successful. For example,
                    // we do not want to cache the task which is faulted .
                    if (t.IsFaulted)
                    {
                        cacheItem.item = null;
                    }
                });

                return await task;
            }
            finally
            {
                cacheItem.semaphore.Release();
            }
        }

        public void Dispose()
        {
            if (isDisposed)
            {
                return;
            }

            memoryCache?.Dispose();
            memoryCache = null;
            isDisposed = true;
        }

        // TODO : Uptake it using Contract.CheckNotDisposed once it is availiale in D365.Common.Internal.
        private void CheckNotDisposed()
        {
            if (isDisposed)
            {
                throw new ObjectDisposedException("ExtendedRedisCache have been disposed.");
            }
        }

        private class LockableCachedItem
        {
            internal SemaphoreSlim semaphore = new SemaphoreSlim(initialCount: 1, maxCount: 1);
            internal Task<T> item = null;
        }
    }
}
